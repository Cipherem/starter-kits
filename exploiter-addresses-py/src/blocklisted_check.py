from datetime import datetime
from functools import lru_cache
from forta_agent import get_json_rpc_url, EntityType
from typing import List, Dict, Tuple

from expiring_dict import ExpiringDict
from forta_agent import Finding, FindingType, FindingSeverity
import requests
from web3 import Web3


from .logger import logger

web3 = Web3(Web3.HTTPProvider(get_json_rpc_url()))
CHAIN_SOURCE_IDS_MAPPING = {
    "ethereum": ["etherscan", "etherscan-tags"],  # Ethereum
    "polygon": ["polygon-tags"],  # Polygon
    "fantom": ["fantom-tags"],  # Fantom
}
GLOBAL_TOTAL_TX_COUNTER = ExpiringDict(ttl=86_400)
BOT_ID = "0x0e82982faa7878af3fad8ddf5042762a3b78d8949da2e301f1adfedc973f25ea"

BLOCKLISTED = ExpiringDict(ttl=86_400)


def get_blocklisted_addresses(address) -> Tuple[str, str]:
    metadata = None, None
    if address in BLOCKLISTED:
        return BLOCKLISTED[address]

    for _, source_ids in CHAIN_SOURCE_IDS_MAPPING.items():
        for source_id in source_ids:
            labels_url = f"https://api.forta.network/labels/state?entities={address}&sourceIds={source_id}&labels=*xploit*,*hish*,*heist*&limit=1"
            try:
                result = requests.get(labels_url).json()

                if result["events"] is not None:
                    label = result["events"][0]
                    data = label["label"]
                    address = data["entity"]
                    wallet_tag = data["label"]
                    metadata = (wallet_tag, source_id)
                BLOCKLISTED[address] = metadata

            except Exception as err:
                logger.error(f"Error obtaining malicious accounts: {err}")
    return metadata


def update_tx_counter(date_hour: str):
    # Total number of transactions in the last 24 hrs
    global GLOBAL_TOTAL_TX_COUNTER
    GLOBAL_TOTAL_TX_COUNTER[date_hour] = GLOBAL_TOTAL_TX_COUNTER.get(date_hour, 0) + 1


def alert_count(chain_id) -> int:
    alert_stats_url = (
        f"https://api.forta.network/stats/bot/{BOT_ID}/alerts?chainId={chain_id}"
    )
    alert_count = 0
    try:
        result = requests.get(alert_stats_url).json()
        alert_count = result["total"]["count"]
    except Exception as err:
        logger.error(f"Error obtaining alert counts: {err}")

    return alert_count


def calculate_anomaly_score(chain_id: int) -> float:
    total_alerts = alert_count(chain_id)
    total_tx_count = sum(GLOBAL_TOTAL_TX_COUNTER.values())
    return min(total_alerts / total_tx_count, 1.0)


def provide_handle_transaction(w3):
    def handle_transaction(transaction_event):
        findings = []

        date_time = datetime.now()
        date_hour = date_time.strftime("%d/%m/%Y %H:00:00")
        update_tx_counter(date_hour)
        addresses = [transaction_event.to, transaction_event.from_]

        blocklisted_addresses = {a: get_blocklisted_addresses(a) for a in addresses}

        for address, metadata in blocklisted_addresses.items():
            wallet_tag, data_source = metadata
            if wallet_tag is not None:
                anomaly_score = calculate_anomaly_score(w3.eth.chain_id)
                exploiter_address = address

                description_msg = (
                    f"Transaction involving an exploiter address: {exploiter_address}"
                )

                if wallet_tag:
                    description_msg += f" with wallet tag: {wallet_tag}"

                labels = [
                    {
                        "entity": transaction_event.hash,
                        "entity_type": EntityType.Transaction,
                        "label": "attacker",
                        "confidence": 1,
                    }
                ]
                finding = Finding(
                    {
                        "name": "Exploiter Address",
                        "description": description_msg,
                        "alert_id": "EXPLOITER-ADDR-TX",
                        "severity": FindingSeverity.High,
                        "type": FindingType.Suspicious,
                        "metadata": {
                            "exploiter_address": exploiter_address,
                            "wallet_tag": wallet_tag,
                            "labels_source": data_source,
                            "anomaly_score": anomaly_score,
                        },
                        "labels": labels,
                    }
                )
                findings.append(finding)

        return findings

    return handle_transaction


real_handle_transaction = provide_handle_transaction(web3)


def handle_transaction(transaction_event):
    return real_handle_transaction(transaction_event)
